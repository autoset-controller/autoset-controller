function [] = ac_path_following(waypoints, initial, cycles)
    % Simulation for Autoset Controller path following
    % Inputs:
    % waypoints - vector of 1x3 position/orientation vectors
    %           - structure: ((x1, y1, t1); (x2, y2, t2); ...)
    % initial   - 1x3 position/orientation vector
    %           - structure: (x0, y0, t0)
    % cycles    - number of cycles to run before execution finishes
    %
    % Behavior:
    % Upon startup, program performs a timestep each time
    % the spacebar is pressed. Position, waypoints, and relevant
    % metrics are displayed.
    % 
    % Notes:
    % - All measurements are in meters
    
    % CONSTANTS:
    p_base_e = 1.5; %distance between encoder wheels
    p_base_m = 2.5; %distance between motor wheels
    p_radius = .15; %radius of encoder wheels
    max_speed = .15 * 2 * pi; % one rotation per second
    
    speed = [0, max_speed]; %left/right speeds in m/s
    timestep = .1;
    
    wp_count = size(waypoints, 1);
    pos = initial;
    
    wp_current = 1;
    wp_target = waypoints(wp_current, :);
    
    f = figure;
    xlim([-6, 6]);
    ylim([-6, 6]);
    
    % Draw Waypoints
    for i = 1:wp_count
        drawPosVec(waypoints(i,:), 0);
    end
        
    complete_cycles = 0;
    
    % MAIN LOOP
    target_speed = .5;
    while(complete_cycles < cycles)
        
        %render positions of platform and waypoint
        hold off
        % Draw Waypoints
        for i = 1:wp_count
            if i == wp_current    
                drawPosVec(waypoints(i,:), 0);
            else
                drawPosVec(waypoints(i,:), 1);
            end
        end
        drawPosVec(pos, 2);
        xlim([-6, 6]);
        ylim([-6, 6]);
        
        %Check if waypoint is passed, and update waypoint
        ispassed = check_passed(pos, wp_target);
        if(ispassed == 1)
            wp_current = wp_current + 1;
            if(wp_current > wp_count)
                wp_current = 1;
                cycles = cycles + 1;
            end
            wp_target = waypoints(wp_current, :);
        end
        
        %Find intersect and distances to intersect
        [intersect, radii] = get_intersect(pos, wp_target);
        
        %Determine appropriate ratio for current scenario
        ratio = get_ratio(speed, p_base_e, p_base_e, pos, wp_target, intersect, radii);
        
        %Set speed of motors: In final version, send out packet
        speed = ratio.^2 * max_speed;
        
        %Simulate movement of platform: Not used in final version
        enc = speed * timestep;
        pos = update_pos(pos, enc, p_radius, p_base_e, p_base_e);
        
        hold on
        
        %Advance timestep
        waitforbuttonpress
    end
    
end

function ratio = get_ratio(speed, p_base_m, p_base_e, pos, wp_target, intersect, radii)
    wp_r = radii(1);
    pos_r = radii(2);
    
    new_speed = speed;
    
    if(~isnan(wp_r))
        
        % get ratio for on-circle movement
        default_speed = [2 * (wp_r - (p_base_m/2)) * pi, 2 * (wp_r + (p_base_m/2)) * pi];
        default_speed = default_speed / norm(default_speed);
        
        % determine change based on ratio of radii
        r_ratio = pos_r/wp_r;
        
        % assign speeds based on relative radii
        % if platform is on the circle
        if(round(r_ratio, 3) == 1)
            new_speed = default_speed;
        % if platform is inside the circle
        elseif(r_ratio < 1)
            new_speed = [default_speed(1), default_speed(2) * abs(r_ratio)];
        % if platform is outside the circle
        else
            new_speed = [default_speed(1), default_speed(2) * abs(r_ratio)];
        end
        new_speed = new_speed / norm(new_speed);
    else
        % platform is oriented parallel to waypoint
        % do not modify
        % TODO: Figure out how to do this
    end
    
    ratio = new_speed;
end

function passed = check_passed(pos, wp_target)
    passed = 0;

    %get linear equation for wp normal
    wp_m = round(round(cos(wp_target(3)), 10) / -round(sin(wp_target(3)), 10), 6);
    wp_b = -1 * (wp_target(1) * wp_m - wp_target(2));
    
    norm_y = wp_m * pos(1) + wp_b
    pos(2)
    if(~isnan(wp_m))
        
    
    if(pos(2) > norm_y)
        passed = 1;
    end
end

function [intersect, radii] = get_intersect(pos, wp_target)

    %CALCULATE CENTER
    %get linear equation for pos normal
    %process in form mx - y = -b
    pos_m = round(cos(pos(3)) / -sin(pos(3)), 6);
    pos_b = -1 * (pos(1) * pos_m - pos(2));
    center_x = NaN;
    if(pos_m == Inf)
        center_x = pos(1);
    end
    %get linear equation for wp normal
    wp_m = round(cos(wp_target(3)) / -sin(wp_target(3)), 6);
    wp_b = -1 * (wp_target(1) * wp_m - wp_target(2));
    
    if(wp_m == Inf)
        center_x = pos(1);
    end
    
    %if normals are parallel, handle special case
    if(pos_m == wp_m)
        % special case: normals are parallel
        center_x = NaN;
        center_y = NaN;
    else
        % find intersect
        % if one normal is vertical
        if(~isnan(center_x))
            if(isnan(pos_b))
                center_y = wp_m*center_x + wp_b;
            else
                center_y = pos_m*center_x + pos_b;
            end
            intersect = [center_x, center_y];
        %standard case
        else
            m = [pos_m, -1; wp_m, -1];
            m = inv(m);
            intersect = m * [pos_b;wp_b];
            intersect = -intersect';
            
            plot([-5, 5], [pos_m*-5 + pos_b, pos_m*5 + pos_b], 'r-')
            plot([-5, 5], [wp_m*-5 + wp_b, wp_m*5 + wp_b], 'b-')
            plot(intersect(1), intersect(2), 'o', 'Color', [.8, 0, .8])
        end
    end
    
    if(isnan(intersect(1)))
        % special case: normals are parallel
        wp_r = NaN;
        pos_r = NaN;
    else
        % find distances to center
        wp_r =  sqrt((intersect(1) - wp_target(1))^2 + (intersect(2) - wp_target(2))^2);
        pos_r = sqrt((intersect(1) - pos(1))^2 + (intersect(2) - pos(2))^2);
       
        % plot circles
        rectangle('Position',[intersect(1) - pos_r, intersect(2) - pos_r, pos_r * 2, pos_r * 2],'Curvature',[1,1]);
        rectangle('Position',[intersect(1) - wp_r, intersect(2) - wp_r, wp_r * 2, wp_r * 2],'Curvature',[1,1]);
        % determine case for position values
        if(round(pos_r, 3) == 0)
            % 
        end
    end
    
    radii = [wp_r, pos_r];
end

function new_pos = update_pos(pos, enc, p_radius, p_base_m, p_base_e)
    dL = enc(1);
    dR = enc(2);
    dt = p_radius / (2 * p_base_e) * (dR - dL);
    
    t_new = pos(3) + dt;
    dp = p_radius/2 * [cos(t_new), cos(t_new); sin(t_new), sin(t_new)] * [dR; dL];
    p_vec = [pos(1); pos(2)] + [dp(1); dp(2)];
    x_new = p_vec(1);
    y_new = p_vec(2);
    
    new_pos = [x_new, y_new, t_new];
end

function drawPosVec(pos, linespec)
    %get display parameters
    if linespec == 0
        ls_line = 'g-';
        ls_point = 'go';
    elseif linespec == 1
        ls_line = 'b-';
        ls_point = 'bo';
    else
        ls_line = 'r-';
        ls_point = 'ro';
    end
    x1 = pos(1) + 0.5 * cos(pos(3));
    y1 = pos(2) + 0.5 * sin(pos(3));
    %plot point
    plot(pos(1), pos(2), ls_point);
    hold on
    %plot arrow
    plot([pos(1), x1], [pos(2), y1], ls_line);
end